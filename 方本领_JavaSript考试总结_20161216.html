<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
		body{background-image: url(http://a1.qpic.cn/psb?/V107sOVO3w2Pbd/7L2Lmev831CB9xi4YB4V4te8H3m9d5PMCA5fYp93PKs!/m/dHgBAAAAAAAA&bo=DAOZAQAAAAAFB7M!&rf=photolist);
			  }
			  #box{width: 1200px;height:auto;margin:auto;}
			  pre{font-size: 20px;}
			  p{font-size: 20px;}
		</style>
	
	</head>
	<body>
		<div id="box">
		<h2>考试总结</h2>	
		<p>a href="javascript:close();">点我</a>这个作用是关闭当前窗口</p>
		<p>alert()属于BOM对象的window方法</p>
		<p>JavaSript函数默认返回值是:undefined</p>
		<p>setTimeout()和setInterval的指向都是window</p>
		<pre>
function test(){
	alert(this);
}
test();
//此处弹出的是window  this指代window。
test3 = function(){
	alert(this);
}
test3();
//此处弹出的是window  this指代window。
		</pre>
		<h3>函数作用域</h3>
	 <pre>
var a = 1;
function test (){
	a++;
	alert(a);  
	var a = 2;
	alert(a);
}
test();
//第一次弹出NAN  第二次弹出2     因为在函数体内部 我们先执行里面的部分 var a = 2;
为局部变量当第一个alert去弹窗时 由于变量提升 找到变量却没有赋值 因为变量声明在后  结果会是undefined  但是遇到a++会被
强转NAN  第二个弹窗由于变量声明在前  所以正常输出 2

    var foo = 1;  
    function bar() {  
        if (!foo) {  
            var foo = 10;  
        }  
        alert(foo);  
    }  
    bar();  

结果是10；

那么下面这个呢？
[javascript] view plain copy

    var a = 1;  
    function b() {  
        a = 10;  
        return;  
        function a() {}  
    }  
    b();  
    alert(a);  

结果是1.
	 </pre>
<p>typeof():检查类型</p>
<pre>
if(document.mylist.length!="undefined"){}这个用法有误
正确的是if (typeof(document.mylist.length)!="undefined"){}
或 if(!isNAN(document.mylist.length)){}
typeof的运算数未定义，返回的就是"undefined"
运算数字为数字typef(x)= 'number'
字符串typeof(x)="string"
布尔值typeof(x)= "bloolean"
数组 对象和null typeof(x)= "object"
函数 typeof(x)"function"
</pre>
<p>f封装函数</p>
<pre>
如何把一个函数封装，我们把函数的主要功能和执行力都写在函数体内部
通过调用的方法，调用我们想到的函数。
例如：
var person = new Person()
function Person(){
	this.name="Bobo";
	this.age = "20";
	this.getName= function(){
		return this.name
	}
}
alert(person.age);
alert(this.getName());
</pre>



<p>方法二</p>
<pre>

function Person (name,age){
      this.name = name;
       this.age = age;
    this.getName = function(){
    	return this.name
    } 
}

上面就是封装好的函数  我们过传参  声明新的变量 来调用封装好的函数
var p1 = new Person("bob",20)
alert(p1.age);
alert(p1.name)
alert(p1.getName.name)
//20 bob bob
var p2 = new Person("jack",30)
alert(p2.age);
alert(p2.name)
alert(p2.getName.name)
//30 jack jack
</pre>


<p>第三种方法</p>
<pre>
function Person(name,age){
	this.name=name;
	this.age = age;
}
Person.prototype.getAge= function(){
	      return  this.age	
		
	}

var p1 = new Person("bob",20);
alert(p1.age);//20
alert(p1.name);//bob
alert(p1.getAge());//20
</pre>
		
			
		</div>
	</body>
</html>
